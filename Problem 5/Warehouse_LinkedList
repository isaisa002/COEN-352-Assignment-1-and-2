public class Warehouse_LinkedList{

        //data members
        private double valAllInv;
        private int nbInvDatabase;
        private SLLDict<String, COEN352.a1.Inventory> wh;

        //constructor
        Warehouse_LinkedList()
        {
                wh = new SLLDict<String, COEN352.a1.Inventory>();
                valAllInv = 0.00;
                nbInvDatabase = 0;
        }
//FUNCTIONS
        // 1. Insert a record
        public void InsertARecord (COEN352.a1.Inventory in)
        {
                wh.insertRec(in.getSKU(),in);
                valAllInv += in.getInventoryValue();
                nbInvDatabase++; //increment
                System.out.println("Record" + in + " was added.");
        }

        // 2. Remove a record given a key
        public void RemoveARecord(String key)
        {
                valAllInv -= wh.findRec(key).getInventoryValue() ;
                wh.removeRec(key);
                
                nbInvDatabase--; //decrement
                System.out.println("Record " + key + " was removed.");

        }

        // 3. Clear the database (removeAll)
        public void clearDatabase()
        {
                //set all to 0
                wh.removeAll();
                nbInvDatabase = 0;
                valAllInv = 0;
        }
        // 4. Find a record given a key
        public void findARecord (String SKU)
        {
                System.out.println("Record " + wh.find(SKU).getSKU()+ " is in the inventory:");
                wh.find(SKU).PrintRecord();

        }

        // 5. Return the number of inventories in the database
        public int InventoriesInDatabase() {
                return nbInvDatabase;
        }

        // 6. Return the total value of all inventories
        public double TotalValueOfInventories() {
                return valAllInv;
        }
        
        //ASSIGNMENT 2
        //PROBLEM 1
        public int[] createIndex() {
                LinkedList<keyValuePair<Key, ELEM>> dictionary_list = new ArrayList<>();
                int i = 0;
                for ( this.A.moveToHead(); this.A.getcurrposition() != null; this.A.getnext())
                {
                        dictionary_list.add(new <keyValuePair<Key, ELEM>(
                                (Key) Integer.valueOf(i), this.A.getcurrposition().getData().value())); //transforms i to key
                        i++;
                }

                QuickSort(dictionary_list, 0, A.length() - 1);
                int[] index = new int[i];
                i = 0;
                for (KVpair<keyValuePair<Key, ELEM> kVpair : dictionary_list) {
                        index[i] = (int)kv.Key();
                        i++;
                }
                return index;
        }

        public void QuickSort (LinkedList<keyValuePair<Key, ELEM>> A, int l, int r) {

                int pivotindex = findpivot(A, l, r); // Pick a pivot
                DSutil.swap(A, pivotindex, r);       // Stick pivot at end
                int k; //k
                if (r > l) {
                        k = partition(A, l, r);
                        if ((k-l) > 1)
                                QuickSort(A, l, k-1);   // Sort left partition
                        if ((r-k) > 1)
                                QuickSort(A, k+1, r);   // Sort right partition
                }
        }

        int partition(LinkedList<keyValuePair<Key, ELEM>> A, int l, int r) {
                E part = A.get(l).value();
                int i = l;
                int j = r;
                        while (A.get(i++).value().compareTo(part) < 0)
                                if (i >= r)
                                        break;
                        while (A.get(--j).value().compareTo(oart) > 0)
                                if (j <= l)
                                        break;
                        if (i >= j)
                                break;
                        else
                                DSUtil.swap(A, i, j);


                if (j == i)
                        return j;
                DSUtil.swap(A, i, j);
                return j;
        }

}

 //PROBLEM 2
        public String query(String attribute, double perct) {

                COEN352.a1.Inventory[] inventories = new COEN352.a1.Inventory[wh.length()];
                inventories = createIndex(attribute);

                //pivot = lower bound of (N * perct)
                double pivot = Math.floor(wh.length()*perct);

                return inventories[pivot].PrintAllRecords();
        }
}
